import com.bmuschko.gradle.docker.tasks.container.*
import com.bmuschko.gradle.docker.tasks.image.*

plugins {
	id "org.kordamp.gradle.markdown" version "2.2.0"
	// https://github.com/bmuschko/gradle-docker-plugin
	id "com.bmuschko.docker-remote-api" version "9.3.2"
	id "com.github.node-gradle.node" version "7.0.0"
	id "com.diffplug.spotless" version "6.20.0"
	id "com.graphql_java_generator.graphql-gradle-plugin" version "1.18.11"
	id "org.beryx.runtime" version "1.13.0"
	id "com.netflix.nebula.rpm" version "11.4.0"
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'application'
apply plugin: 'jacoco'
apply plugin: 'checkstyle'
apply plugin: 'project-report' // adds dependencyReport and htmlDependencyReport tasks

java {
  sourceCompatibility = 17
  targetCompatibility = 17
}

boolean isTestEnv = project.hasProperty("testEnv")
String dropwizardVersion = "2.1.7"
String logbackVersion = "1.3.5"
String log4jVersion = "2.20.0"
String keycloakVersion = "22.0.3"
String psqlPushDataPath = "/var/tmp"
String keycloakContainerPath = "/opt/keycloak"
String keycloakPushDataPath = "${keycloakContainerPath}/data"
String hostKeycloakPath = "${rootProject.projectDir}/keycloak"

// If defined, load alternatives for variables
if (!isTestEnv && file('localSettings.gradle').exists()) {
	apply from: 'localSettings.gradle'
} else if (isTestEnv && file('localTestSettings.gradle').exists()) {
	apply from: 'localTestSettings.gradle'
}

// Defaults for development variables
run.environment("DB_DRIVER", run.environment["DB_DRIVER"] ?: "postgresql")
run.environment("ANET_DB_SERVER", run.environment["ANET_DB_SERVER"] ?: "localhost")
run.environment("ANET_DB_NAME", run.environment["ANET_DB_NAME"] ?: isTestEnv ? "testAnet" : "devAnet")
run.environment("ANET_DB_USERNAME", run.environment["ANET_DB_USERNAME"] ?: isTestEnv ? "anetTestUser" : "anetDevUser")
run.environment("ANET_DB_PASSWORD", run.environment["ANET_DB_PASSWORD"] ?: isTestEnv ? "Test-P@ssw0rd" : "Dev-P@ssw0rd")
run.environment("ANET_SA_PASSWORD", run.environment["ANET_SA_PASSWORD"] ?: "SA-P@ssw0rd")
run.environment("ANET_DB_PORT", run.environment["ANET_DB_PORT"] ?: "5432")
run.environment("ANET_DB_EXPOSED_PORT", run.environment["ANET_DB_EXPOSED_PORT"] ?: (isTestEnv ? "5433" : "5432"))
run.environment("ANET_PORT", run.environment["ANET_PORT"] ?: isTestEnv ? "8180" : "8080")
run.environment("ANET_ADMIN_PORT", run.environment["ANET_ADMIN_PORT"] ?: isTestEnv ? "8181" : "8081")
run.environment("ANET_SMTP_DISABLE", run.environment["ANET_SMTP_DISABLE"] ?: isTestEnv ? "false" : "true")
run.environment("ANET_SMTP_SERVER", run.environment["ANET_SMTP_SERVER"] ?: "localhost")
run.environment("ANET_SMTP_USERNAME", run.environment["ANET_SMTP_USERNAME"] ?: "")
run.environment("ANET_SMTP_PASSWORD", run.environment["ANET_SMTP_PASSWORD"] ?: "")
run.environment("ANET_SMTP_PORT", run.environment["ANET_SMTP_PORT"] ?: isTestEnv ? 1125 : 1025)
run.environment("ANET_SMTP_STARTTLS", run.environment["ANET_SMTP_STARTTLS"] ?: "true")
run.environment("ANET_SMTP_SSLTRUST", run.environment["ANET_SMTP_SSLTRUST"] ?: run.environment["ANET_SMTP_SERVER"])
run.environment("ANET_SMTP_HTTP_PORT", run.environment["ANET_SMTP_HTTP_PORT"] ?: isTestEnv ? 1180 : 1080)
run.environment("ANET_DICTIONARY_NAME", run.environment["ANET_DICTIONARY_NAME"] ?: "anet-dictionary.yml")

String adminOrgName = run.environment["ANET_ADMIN_ORG_NAME"] ?: "ANET Administrators"
String adminPosName = run.environment["ANET_ADMIN_POS_NAME"] ?: "ANET Administrator"
String adminFullName = run.environment["ANET_ADMIN_FULL_NAME"] ?: "DMIN, Arthur"
String adminDomainUsername = run.environment["ANET_ADMIN_DOMAIN_USERNAME"] ?: "arthur"

String dbContainerName = isTestEnv ? "anet-psql-test-server" : "anet-psql-server"
String fakeSmtpContainerName = isTestEnv ? "anet-fake-smtp-test-server" : "anet-fake-smtp-server"
String keycloakContainerName = "anet-keycloak-server"

// In this section you declare where to find the dependencies of your project
repositories {
	mavenCentral()
	maven { url 'https://jitpack.io' }
}

// In this section you declare the dependencies for your production and test code
dependencies {
	// The production code uses the SLF4J logging API at compile time
	implementation "io.dropwizard:dropwizard-core:${dropwizardVersion}"
	implementation "io.dropwizard:dropwizard-jdbi3:${dropwizardVersion}"
	implementation "io.dropwizard:dropwizard-migrations:${dropwizardVersion}"
	implementation "io.dropwizard:dropwizard-auth:${dropwizardVersion}"
	implementation "io.dropwizard:dropwizard-views-freemarker:${dropwizardVersion}"
	implementation 'io.dropwizard-bundles:dropwizard-configurable-assets-bundle:1.3.5'
	implementation "io.dropwizard:dropwizard-forms:${dropwizardVersion}"
	implementation "org.jdbi:jdbi3-postgres:3.41.0"

	implementation 'ru.vyarus.guicey:guicey-jdbi3:5.9.1'
	implementation 'com.google.guava:guava:32.1.2-jre' // Pick the non-Android version of Guice
	implementation 'commons-collections:commons-collections:3.2.2'

	// Supported database is PostgreSQL:
	implementation 'org.postgresql:postgresql:42.6.0'
	implementation 'org.liquibase:liquibase-core:4.23.1'

	// For caching domain users (used in every request in the AuthenticationFilter)
	implementation('org.ehcache:ehcache:3.10.8') {
		capabilities {
			requireCapability('org.ehcache:ehcache-jakarta')
		}
	}
	implementation 'javax.cache:cache-api:1.1.1'
	implementation 'commons-beanutils:commons-beanutils:1.9.4'

	implementation 'org.simplejavamail:simple-java-mail:8.1.3'
	implementation 'org.eclipse.angus:jakarta.mail:2.0.2'
	implementation "ch.qos.logback:logback-classic:${logbackVersion}"
	implementation "ch.qos.logback:logback-core:${logbackVersion}"
	implementation "ch.qos.logback:logback-access:${logbackVersion}"
	implementation 'com.googlecode.owasp-java-html-sanitizer:owasp-java-html-sanitizer:20220608.1'
	implementation 'com.mikesamuel:json-sanitizer:1.2.3'
	// Authentication
	implementation 'de.ahus1.keycloak.dropwizard:keycloak-dropwizard:1.2.0'
	implementation "org.keycloak:keycloak-jetty94-adapter:${keycloakVersion}"
	implementation "org.keycloak:keycloak-jaxrs-oauth-client:${keycloakVersion}"
	implementation "org.keycloak:keycloak-policy-enforcer:${keycloakVersion}"

	// Used for converting GraphQL request output to XML:
	implementation 'com.github.javadev:underscore-lodash:1.26'
	// For JSON schema validation, supports detailed error reporting
	implementation 'com.networknt:json-schema-validator:1.0.86'

	// used for writing Excel documents
	implementation 'org.apache.poi:poi:5.2.3'
	implementation 'org.apache.poi:poi-ooxml:5.2.3'
	// For inferring MIME types of attachments
	implementation 'org.apache.tika:tika-core:2.8.0'

	// For parsing HTML to check for 'empty' input
	implementation 'org.jsoup:jsoup:1.16.1'

	// For fast and simple image scaling
	implementation 'net.coobird:thumbnailator:0.4.20'

	// GraphQL dependencies
	implementation 'com.graphql-java:graphql-java:20.2'
	implementation 'com.graphql-java:java-dataloader:3.2.0'
	implementation 'io.leangen.graphql:spqr:0.12.1'
	// The graphql-java-client-runtime module aggregates all dependencies for the generated code,
	// including the plugin runtime
	testImplementation('com.graphql-java-generator:graphql-java-client-runtime:1.18.11') {
		// We don't actually need any of these (dragged in through org.springframework.boot)
		exclude group: 'io.netty'
	}
	// We use some extended scalars in `generateClientCodeConf` below
	testImplementation 'com.graphql-java:graphql-java-extended-scalars:20.0'

	testImplementation "io.dropwizard:dropwizard-testing:${dropwizardVersion}"
	testImplementation "io.dropwizard:dropwizard-client:${dropwizardVersion}"
	testImplementation 'org.apache.commons:commons-io:1.3.2'

	testImplementation 'org.assertj:assertj-core:3.24.2'

	testImplementation 'org.powermock:powermock-api-mockito2:2.0.9'
	testImplementation 'org.powermock:powermock-module-junit4:2.0.9'
	testImplementation 'org.powermock:powermock-module-junit4-rule:2.0.9'

	testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'
	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'

	// Avoid "ERROR StatusLogger Log4j2 could not find a logging implementation.
	// Please add log4j-core to the classpath. Using SimpleLogger to log to the console..."
	implementation "org.apache.logging.log4j:log4j-api:${log4jVersion}"
	implementation "org.apache.logging.log4j:log4j-to-slf4j:${log4jVersion}"
}

configurations.all {
	// Exclude transitive dependency Apache Xalan (e.g. through poi-ooxml), so we use the TransformerFactoryImpl from the JVM
	exclude module: 'xalan'
	// Also exclude XML API's to avoid (Eclipse) warnings like
	//   "The package org.w3c.dom is accessible from more than one module: <unnamed>, java.xml"
	exclude group: 'xml-apis'
}

test {
	useJUnitPlatform()
	jacoco {
		destinationFile = file("$buildDir/jacoco/test-${run.environment['DB_DRIVER']}.exec")
	}
}

jacoco {
	toolVersion = "0.8.10"
}

jacocoTestReport {
	executionData.setFrom project.fileTree(dir: "$buildDir", include: "jacoco/test-*.exec")
	reports {
		xml.required = true
		html.required = true
	}
}

//Set project version to git tag
def proc = "git describe".execute(null, projectDir);
proc.waitFor();
project.version = proc.text.trim();

runtime {
	options = ['--vm=server', '--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']
	modules = [
		'java.sql',
		'java.desktop',
		'java.xml',
		'java.logging',
		'java.management',
		'jdk.crypto.cryptoki',
		'jdk.crypto.ec',
		'jdk.unsupported',
		'java.security.jgss',
		'java.naming',
		'java.transaction.xa',
		'java.security.sasl',
		'java.instrument',
		'java.scripting',
		'java.xml.crypto'
	]

	jpackage {
	    appVersion = project.version.replace("-",".") // rpmbuild doesn't like versions with dashes
	}
}

processResources {
	filesMatching('**/version.properties') {
		filter {
			it.replace('APP_VERSION_TOKEN', project.version)
		}
	}
}
processResources.outputs.upToDateWhen{ false }

def projectBranch = "git rev-parse --abbrev-ref HEAD".execute(null, projectDir);
projectBranch.waitFor();
projectBranch = projectBranch.text.trim();

project.group = "ncia"

application {
  mainClass = "mil.dds.anet.AnetApplication"
  applicationDefaultJvmArgs = ["-Djava.library.path=MY_APP_HOME/lib"]
}

String anetConfig = "anet.yml"

String dbLoc = run.environment['ANET_DB_SERVER']
if (run.environment['ANET_DB_EXPOSED_PORT']) {
	dbLoc = dbLoc + ":" + run.environment['ANET_DB_EXPOSED_PORT'].toString()
}
if (!run.environment['ANET_DB_USERNAME']) {
	run.environment('ANET_DB_USERNAME', run.environment['USER'])
}

if (run.environment['DB_DRIVER'] == "sqlserver") {
	run.environment("ANET_DB_DRIVER", "com.microsoft.sqlserver.jdbc.SQLServerDriver")
	run.environment("ANET_DB_URL", "jdbc:sqlserver://${dbLoc};databaseName=${run.environment['ANET_DB_NAME']}")
} else if (run.environment['DB_DRIVER'] == "postgresql") {
	run.environment("ANET_DB_DRIVER", "org.postgresql.Driver")
	run.environment("ANET_DB_URL", "jdbc:postgresql://${dbLoc}/${run.environment['ANET_DB_NAME']}")
} else {
	throw new GradleException( "Unsupported DB_DRIVER value \'${run.environment['DB_DRIVER']}\'")
}

test.environment = run.environment

run.args = ["server", anetConfig]

task checkConfig(dependsOn: 'compileJava', type: JavaExec) {
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	args = ["check", anetConfig]
}

task buildClient(dependsOn: 'yarn', type: YarnTask) {
	group = "build"
	description = "Builds the client application."
	inputs.file("client/yarn.lock").withPathSensitivity(PathSensitivity.RELATIVE)
	inputs.dir("client/src").withPathSensitivity(PathSensitivity.RELATIVE)
	inputs.dir("client/config").withPathSensitivity(PathSensitivity.RELATIVE)
	inputs.dir("client/public").withPathSensitivity(PathSensitivity.RELATIVE)
	outputs.dir("$buildDir/resources/main/assets/client")
	outputs.cacheIf { true }
	environment = [ "ANET_TEST_MODE": isTestEnv ? "true" : "false" ]
	args = ['run', 'build']
}

task dbWait(dependsOn: 'compileJava', type: JavaExec) {
	group = "database runtime"
	description = "Wait for the ANET database to become available."
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	args = ["waitForDB", anetConfig]
}
dbWait.mustRunAfter('dockerStartDB')

// Create the task that runs the initialization command. Run with:
//   ./gradlew dbInit
// to use the defaults. You can override the defaults with environment variables:
//   env ANET_ADMIN_ORG_NAME="ACME Administrators Inc." \
//       ANET_ADMIN_POS_NAME="The ANET admin" \
//       ANET_ADMIN_FULL_NAME="DOE, John" \
//       ANET_ADMIN_DOMAIN_USERNAME="johndoe" \
//       ./gradlew dbInit
// To see all options, run:
//   ./gradlew dbInit -Pargs="--help"
// which will print the help.
task dbInit(dependsOn: 'compileJava', type: JavaExec) {
	group = "database runtime"
	description = "Runs the ANET database initialization command."
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	def cmdline = ["init"]
	if (project.hasProperty("args")) {
		cmdline.add(project.args)
	} else {
		cmdline.addAll([
			"--adminOrgName", adminOrgName,
			"--adminPosName", adminPosName,
			"--adminFullName", adminFullName,
			"--adminDomainUsername", adminDomainUsername
		])
	}
	cmdline << anetConfig
	args cmdline
}

task dbStatus(dependsOn: 'compileJava', type: JavaExec) {
	group = "database runtime"
	description = "Runs the ANET database status (Liquibase) command."
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	args = ["db", "status", anetConfig]
}

task dbPrep(dependsOn: 'compileJava', type: JavaExec) {
	group = "database runtime"
	description = "Runs the ANET database preparation command."
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	args = ["dbScript", "-S", "prepare-psql.sql", anetConfig]
}
dbPrep.mustRunAfter('dbWait')

task dbMigrate(dependsOn: dbPrep, type: JavaExec) {
	group = "database runtime"
	description = "Runs the ANET database migration (Liquibase) command."
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	args = ["db", "migrate", anetConfig]
	if (project.hasProperty("dry-run")) {
		args += "--dry-run"
	}
}
dbMigrate.mustRunAfter('dbDrop')

task dbTest(dependsOn: 'compileJava', type: JavaExec) {
	group = "database runtime"
	description = "Runs the ANET database migration test (Liquibase) command."
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	args = ["db", "test", anetConfig]
}
dbTest.mustRunAfter('dbWait')

task dbRollback(dependsOn: 'compileJava', type: JavaExec) {
	group = "database runtime"
	description = "Runs the ANET database migration rollback (Liquibase) command."
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	args = ["db", "rollback", anetConfig, "--count", "1"]
	if (project.hasProperty("dry-run")) {
		args += "--dry-run"
	}
}
dbRollback.mustRunAfter('dbWait')

task dbDrop(dependsOn: 'compileJava', type: JavaExec) {
	group = "database runtime"
	description = "Runs the ANET database drop-all (Liquibase) command."
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	args = ["db", "drop-all", "--confirm-delete-everything", anetConfig]
}
dbDrop.mustRunAfter('dbWait')

task pushPsqlBaseData(type: DockerCopyFileToContainer) {
	group = "database runtime"
	description = "Push SQL base data to PostgreSQL"
	containerId = dbContainerName
	hostPath = "${projectDir}/insertBaseData-psql.sql"
	remotePath = psqlPushDataPath
}
pushPsqlBaseData.mustRunAfter('dockerStartDB')

task pushPsqlImageData(type: DockerCopyFileToContainer) {
	group = "database runtime"
	description = "Push SQL base data to PostgreSQL"
	containerId = dbContainerName
	hostPath = "${projectDir}/src/test/resources/assets/default_avatar.png"
	remotePath = psqlPushDataPath
}
pushPsqlImageData.mustRunAfter('dockerStartDB')

task dbLoad(dependsOn: [pushPsqlBaseData, pushPsqlImageData], type: DockerExecContainer) {
	group = "database runtime"
	description = "Runs the ANET database load command for PostgreSQL; loads demo data."
	containerId = dbContainerName
	commands = [ ["psql", "-U", run.environment["ANET_DB_USERNAME"], "-d", run.environment["ANET_DB_NAME"], "-f", "${psqlPushDataPath}/insertBaseData-psql.sql"] as String[] ]
}
dbLoad.mustRunAfter('dbMigrate')

task deleteDbDump(type: DockerExecContainer) {
	group = "database runtime"
	description = "Deletes the database dump in the container"
	containerId = dbContainerName
	commands = [ ["rm", "-f", "${psqlPushDataPath}/anet-db-dump.sql"] as String[] ]
}

task dbDump(type: DockerExecContainer, dependsOn: deleteDbDump) {
	group = "database runtime"
	description = "Dumps the ANET database in the container"
	containerId = dbContainerName
	commands = [ ["pg_dump", "-U", run.environment["ANET_DB_USERNAME"], "-d", run.environment["ANET_DB_NAME"], "-f", "${psqlPushDataPath}/anet-db-dump.sql"] as String[] ]
}

task extractDbDump(type: DockerCopyFileFromContainer, dependsOn: dbDump) {
	group = "database runtime"
	description = "Extracts the dumped database from the container"
	containerId = dbContainerName
	hostPath = "${buildDir}/db/anet-db-dump.sql"
	remotePath = "${psqlPushDataPath}/anet-db-dump.sql"
}

task pushDbDump(type: DockerCopyFileToContainer) {
	group = "database runtime"
	description = "Copies the database dump to the container"
	containerId = dbContainerName
	hostPath = "${buildDir}/db/anet-db-dump.sql"
	remotePath = psqlPushDataPath
}

task dbRestore(type: DockerExecContainer, dependsOn: pushDbDump) {
	group = "database runtime"
	description = "Restores the ANET database in the container"
	containerId = dbContainerName
	commands = [ ["psql", "-U", run.environment["ANET_DB_USERNAME"], "-d", run.environment["ANET_DB_NAME"], "-f", "${psqlPushDataPath}/anet-db-dump.sql"] as String[] ]
}

task dockerBuildImage(dependsOn: installDist, type: DockerBuildImage) {
	description = "Builds anet-app-server container image."
	doFirst {
		copy {
			from 'docker/anet-app-server/Dockerfile'
			into 'build/install'
		}
	}
	inputDir =  project.file('build/install')
	def resultTags = ["ncia/anet-app-server:${project.version}"]
	if (projectBranch=="main")
		resultTags << 'ncia/anet-app-server:latest'
	images = resultTags
}

task dockerPushLatestImage(type: DockerPushImage) {
	images = ['ncia/anet-app-server:latest']
}

task dockerPushImage(type: DockerPushImage) {
	images = ["ncia/anet-app-server:${project.version}"]
}

// Database container (PostgreSQL)

task dockerPullDB(type: DockerPullImage) {
	group = "database container"
	image = "postgres:latest"
	description = "Pulls a docker image for the ANET DB from ${image}."
}

task dockerCreateDB(dependsOn: dockerPullDB, type: DockerCreateContainer) {
	group = "database container"
	imageId = dockerPullDB.getImage()
	containerName = dbContainerName
	description = "Creates an ANET SQL DB container named ${dbContainerName}."
	hostConfig.shmSize = 1024*1024*1024L
	hostConfig.binds = ["${projectDir}":"/hostdata"] + run.environment.get("DOCKER_MOUNTS", [:])
	withEnvVar('POSTGRES_DB', run.environment["ANET_DB_NAME"])
	withEnvVar('POSTGRES_USER', run.environment["ANET_DB_USERNAME"])
	withEnvVar('POSTGRES_PASSWORD', run.environment["ANET_DB_PASSWORD"])
	hostConfig.portBindings = ["${run.environment["ANET_DB_EXPOSED_PORT"]}:${run.environment["ANET_DB_PORT"]}"]
}

// need to make this invoke dockerCreateDB if there is no ${dbContainerName} and possibly get newer image if available
task dockerStartDB(type: DockerStartContainer) {
	group = "database container"
	description = "Starts ${dbContainerName} container."
	targetContainerId { dbContainerName }
}
dockerStartDB.mustRunAfter('dockerCreateDB')

task dockerStopDB(type: DockerStopContainer) {
	group = "database container"
	description = "Stops ${dbContainerName} container."
	targetContainerId { dbContainerName }
}

task dockerRemoveDB(type: DockerRemoveContainer) {
	group = "database container"
	description = "Removes ${dbContainerName} container."
	targetContainerId { dbContainerName }
}
dockerRemoveDB.mustRunAfter('dockerStopDB')

// Keycloak container

task dockerPullKeycloak(type: DockerPullImage) {
	group = "keycloak container"
	image = "quay.io/keycloak/keycloak:${keycloakVersion}"
	description = "Pulls a docker image for keycloak from ${image}."
}

task dockerCreateKeycloak(dependsOn: dockerPullKeycloak, type: DockerCreateContainer) {
	group = "keycloak container"
	imageId = dockerPullKeycloak.getImage()
	containerName = keycloakContainerName
	description = "Creates a keycloak container named ${keycloakContainerName}."
	hostConfig.portBindings = ["9080:8080", "9443:8443"]
	hostConfig.binds = run.environment.get("DOCKER_MOUNTS", [:])
	withEnvVar("KEYCLOAK_ADMIN", "admin")
	withEnvVar("KEYCLOAK_ADMIN_PASSWORD", "admin")
	cmd = ["start-dev", "--import-realm"]
}

task dockerConfigureKeycloak(dependsOn: dockerCreateKeycloak, type: DockerCopyFileToContainer) {
	group = "keycloak container"
	description = "Push REALM configuration to Keycloak"
	containerId = keycloakContainerName
	hostPath = "${rootProject.projectDir}/keycloak/import"
	remotePath = keycloakPushDataPath
}

task dockerStartKeycloak(type: DockerStartContainer) {
	group = "keycloak container"
	description = "Starts ${keycloakContainerName} container."
	containerId = keycloakContainerName
}

task dockerExportKeycloakRealm(type: DockerExecContainer) {
	group = "keycloak container"
	description = "Epxorts ANET-Realm from ${keycloakContainerName} container."
	containerId = keycloakContainerName
	commands = [ ["/bin/bash", "${keycloakContainerPath}/bin/kc.sh", "export", "--dir", "${keycloakPushDataPath}/export", "--users", "realm_file"] as String[] ]
}

task dockerGetKeycloakConfiguration(dependsOn: dockerExportKeycloakRealm, type: DockerCopyFileFromContainer) {
	description = "Pull REALM configuration from Keycloak"
	containerId = keycloakContainerName
	hostPath = "${hostKeycloakPath}/import/ANET-realm.json"
	remotePath = "${keycloakPushDataPath}/export/ANET-realm.json"
}

task dockerStopKeycloak(type: DockerStopContainer) {
	group = "keycloak container"
	description = "Stops ${keycloakContainerName} container."
	containerId = keycloakContainerName
}

task dockerRemoveKeycloak(type: DockerRemoveContainer) {
	group = "keycloak container"
	description = "Removes ${keycloakContainerName} container."
	containerId = keycloakContainerName
}
dockerRemoveKeycloak.mustRunAfter('dockerStopKeycloak')

// Fake SMTP server container

task dockerPullFakeSmtpServer(type: DockerPullImage) {
	group = "fake-smtp-server container"
	image = "devoto13/fake-smtp-server:0.1.0" // No 'latest' available yet
	description = "Pulls a docker image for the fake-smtp-server from ${image}."
}

task dockerCreateFakeSmtpServer(dependsOn: dockerPullFakeSmtpServer, type: DockerCreateContainer) {
	group = "fake-smtp-server container"
	imageId = dockerPullFakeSmtpServer.getImage()
	containerName = fakeSmtpContainerName
	description = "Creates a fake-smtp-server container named ${fakeSmtpContainerName}."
	exposePorts("tcp", [1025, 1080])
	hostConfig.portBindings = ["${run.environment["ANET_SMTP_PORT"]}:1025", "${run.environment["ANET_SMTP_HTTP_PORT"]}:1080"]
}

task dockerStartFakeSmtpServer(type: DockerStartContainer) {
	group = "fake-smtp-server container"
	description = "Starts ${fakeSmtpContainerName} container."
	containerId = fakeSmtpContainerName
}

task dockerStopFakeSmtpServer(type: DockerStopContainer) {
	group = "fake-smtp-server container"
	description = "Stops ${fakeSmtpContainerName} container."
	containerId = fakeSmtpContainerName
}

task dockerRemoveFakeSmtpServer(type: DockerRemoveContainer) {
	group = "fake-smtp-server container"
	description = "Removes ${fakeSmtpContainerName} container."
	containerId = fakeSmtpContainerName
}
dockerRemoveFakeSmtpServer.mustRunAfter('dockerStopFakeSmtpServer')

// Create the task that runs the maintenance command. Run e.g. with:
//   ./gradlew dbMaintenance -Pargs="--clearEmptyBiographies"
// To see all options, run just:
//   ./gradlew dbMaintenance
// which will print the help.
task dbMaintenance(dependsOn: 'compileJava', type: JavaExec) {
	group = "database runtime"
	description = "Runs the ANET database maintenance command."
	classpath = sourceSets.main.runtimeClasspath
	environment(run.environment)
	mainClass = application.mainClass
	def cmdline = ["maintenance"]
	if (project.hasProperty("args")) {
		cmdline.addAll(project.args.split("\\s+"))
	} else {
		cmdline << "--help"
	}
	cmdline << anetConfig
	args cmdline
}

// Execute the GraphQL plugin before Java compile, so that all test (re)sources are generated on time
compileTestJava.dependsOn generateClientCode
processTestResources.dependsOn generateClientCode

// Add the generated (re)sources as a Java test (re)source folder
sourceSets.test.java.srcDirs += 'build/generated/sources/graphqlGradlePlugin'
sourceSets.test.resources.srcDirs += 'build/generated/resources/graphqlGradlePlugin'
// and ignore optional problems in Eclipse
eclipse.classpath.file {
	whenMerged { classpath ->
		classpath.entries.each { entry ->
			if (entry.path.contains('graphqlGradlePlugin')) {
				entry.entryAttributes['ignore_optional_problems'] = true
			}
		}
	}
}

// And remove the auto-added generated (re)sources from the main Java (re)source
task prepareCompileJava(dependsOn: 'generateClientCode') {
	doFirst {
		logger.info("De-registering generated folders for task prepareCompileJava")
		def mainJavaSrcDirs = sourceSets.main.java.srcDirs.toList()
		mainJavaSrcDirs.removeAll { it.name == 'graphqlGradlePlugin' }
		sourceSets.main.java.srcDirs = mainJavaSrcDirs
	}
}
compileJava.dependsOn prepareCompileJava
task prepareProcessResources(dependsOn: 'generateClientCode') {
	doFirst {
		logger.info("De-registering generated folders for task prepareProcessResources")
		def mainResourceSrcDirs = sourceSets.main.resources.srcDirs.toList()
		mainResourceSrcDirs.removeAll { it.name == 'graphqlGradlePlugin' }
		sourceSets.main.resources.srcDirs = mainResourceSrcDirs
	}
}
processResources.dependsOn('prepareProcessResources', 'buildClient')

// Configure the GraphQL Gradle Plugin; all available parameters are described here:
// https://graphql-maven-plugin-project.graphql-java-generator.com/graphql-maven-plugin/generateClientCode-mojo.html
generateClientCodeConf {
	schemaFileFolder = 'src/test/resources/'
	schemaFilePattern = 'anet.graphql'
	packageName = 'mil.dds.anet.test.client'
	// Set recommended parameters to respect the future 2.x behavior
	separateUtilityClasses = true
	copyRuntimeSources = false
	generateDeprecatedRequestResponse = false
	skipGenerationIfSchemaHasNotChanged = true
	customScalars = [
		[
			graphQLTypeName: "Instant",
			javaType: "java.time.Instant",
			graphQLScalarTypeStaticField: "mil.dds.anet.graphql.DateTimeMapper.GraphQLInstant"
		],
		[
			graphQLTypeName: "Base64String",
			javaType: "byte[]",
			graphQLScalarTypeStaticField: "com.graphql_java_generator.customscalars.GraphQLScalarTypeBase64String.GraphQLBase64String"
		],
		[
			graphQLTypeName: "Long",
			javaType: "java.lang.Long",
			graphQLScalarTypeStaticField: "graphql.scalars.ExtendedScalars.GraphQLLong"
		],
		[
			graphQLTypeName: "Map_String_ObjectScalar",
			javaType: "java.util.HashMap",
			graphQLScalarTypeStaticField: "graphql.scalars.ExtendedScalars.Object"
		],
		[
			graphQLTypeName: "UNREPRESENTABLE",
			javaType: "java.lang.Object",
			graphQLScalarTypeStaticField: "graphql.scalars.ExtendedScalars.Object"
		]
	]
}

jar.dependsOn buildClient
run.dependsOn buildClient

run.mustRunAfter('dbLoad', 'dockerStartKeycloak')
test.mustRunAfter('dbLoad', 'dockerStartKeycloak', 'dockerStartFakeSmtpServer')

jar {
	// Add classpath to manifest to prevent variables in startScripts getting too long
	manifest {
		attributes "Class-Path": configurations.runtimeClasspath.files*.name.join(" ")
	}
}

//Configure the Java Checkstyle settings. Run with ./gradlew check
checkstyle {
	configFile = rootProject.file('config/google_checks.xml')
	toolVersion = '10.12.2'
}
//Easiest way to avoid checking generated code
checkstyleTest {
	source = fileTree('src/test/java')
}

spotless {
	java {
		importOrderFile 'config/google.importorder'
		eclipse().configFile('config/eclipse-java-google-style.xml')
		//Exclude generated code
		targetExclude 'build/generated/**'
	}
}

//Configure extra files to include the distribution file
distributions {
	main {
		contents {
			into('docs/') {
				from('anet.yml') { rename('anet.yml', 'anet.yml.template') }
				from('anet-dictionary.yml') { rename('anet-dictionary.yml', 'anet-dictionary.yml.template') }
				from(markdownToHtml)
				from('prepare-psql.sql')
			}
		}
	}
}

startScripts {
	// Clear up the classpath because the jar has it in its manifest
	classpath = jar.outputs.files
	doLast {
		unixScript.text = unixScript.text.replace('MY_APP_HOME', '\$APP_HOME')
		windowsScript.text = windowsScript.text.replace('MY_APP_HOME', '%APP_HOME%')
	}
}

//Configure Markdown plugin
allprojects {
	markdownToHtml.sourceDir = file("docs")
	markdownToHtml.outputDir = file("$buildDir/documentation")
	markdownToHtml.hardwraps = true
}

node {
	nodeProjectDir = file("${project.projectDir}/client")
	version = '18.14.0'
	yarnVersion = '1.22.19'
	download = true
}

task prettierCheck(type: YarnTask) {
	args = ["run", "prettier:check"]
}

task distRpm(dependsOn: "jpackageImage", type: Rpm) {
	release = '0'
	prefix '/opt' // Relocations: /opt
	arch = 'x86_64'
	os = LINUX
	into '/opt'
	from(jpackageImage.outputs.files)
	into('anet/docs/') {
		from('anet.yml') { rename('anet.yml', 'anet.yml.template') }
		from('anet-dictionary.yml') { rename('anet-dictionary.yml', 'anet-dictionary.yml.template') }
		from(markdownToHtml)
		from('prepare-psql.sql')
	}
}

task distInDocker {
	group = "RH8 RPM build container"
	String image = "openjdk:17-oraclelinux8"
	String rh8ContainerName = "oracle-linux8"
	def cacheDir = "/tmp/.cache"
	def gradleOptions = "-g ${cacheDir} --project-cache-dir ${cacheDir}"

	doFirst {
		def uidProc = "id -u".execute()
		uidProc.waitFor()
		def UID = uidProc.text.trim()

		def gidProc = "id -g".execute()
		gidProc.waitFor()
		def GID = gidProc.text.trim()

		// create and start rh8 docker container
		exec {
			executable "docker"
			args "run", "--detach", "--name", rh8ContainerName, "-e", "UID=${UID}", "-e", "GID=${GID}", "-it", "-v", "${projectDir}:/source/anet", image
		}
		// add user to rh8 container
		exec {
			executable "docker"
			args "exec", rh8ContainerName, "sh", "-c", "groupadd -g ${GID} anetgroup ; useradd -u ${UID} -g ${GID} anetuser"
		}
		// install git,yum and "Development Tools"
		exec {
			executable "docker"
			args "exec", rh8ContainerName, "sh", "-c", "microdnf -y install git yum ; yum -y groupinstall \"Development Tools\""
		}
		// clean and build zip & rpm in docker
		exec {
			executable "docker"
			args "exec", "-u", "anetuser", rh8ContainerName, "sh", "-c", "cd /source/anet ;  rm -rf client/node_modules/ ;" +
					" env YARN_CACHE_FOLDER=${cacheDir} ./gradlew ${gradleOptions} clean distZip distRpm"
		}
		// test rpm in docker
		exec {
			executable "docker"
			args "exec", rh8ContainerName, "sh", "-c", "rpm -i /source/anet/build/distributions/anet*.rpm ;" +
					" cd /opt/anet ; bin/anet --help"
		}
		// list build
		exec {
			executable "ls"
			args "-la", "build/distributions/"
		}
	}
	doLast {
		// stop and remove rh8 container
		exec {
			executable "docker"
			args "rm", "-f", rh8ContainerName
		}
	}
}
